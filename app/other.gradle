import groovy.json.JsonSlurper
import groovy.xml.MarkupBuilder

final groupName = 'app'

dependencyUpdates.group = groupName
generateGitProperties.group = groupName
generateLicenses.group = groupName
getDependencies.group = groupName
licensesCleanUp.group = groupName
removeUnusedResources.group = groupName

ext.loadProperties = { String pathname ->
    def props = new Properties()
    def file = file(pathname)
    if (file.file) {
        file.withInputStream { props.load(it) }
    }
    props
}

// make sure the generateGitProperties task always executes (even when git.properties is not changed)
generateGitProperties.outputs.upToDateWhen { false }

task appGenerateGitProperties {
    group = groupName
    dependsOn generateGitProperties
    doLast {
        try {
            project.ext.gitProps
        } catch (MissingPropertyException ignored) {
            Properties props = loadProperties('default.properties')
            project.ext[gitProperties.extProperty] = new HashMap(props)
        }
    }
}

task appGenerateGitBuildConstants {
    group = groupName
    dependsOn appGenerateGitProperties
    doLast {
        /*def id = project.ext.gitProps['git.commit.id']
        def dirty = project.ext.gitProps['git.dirty']

        android.defaultConfig.buildConfigField 'String', 'GIT_COMMIT_ID', "\"$id\""
        android.defaultConfig.buildConfigField 'boolean', 'GIT_DIRTY', "$dirty"*/

        def url = project.ext.gitProps['git.remote.origin.url']
        def matcher = url =~ /(git@github\.com):(.*)\/(.*)\.(git)/

        if (matcher.matches()) {
            def owner = matcher[0][2]
            def repo = matcher[0][3]

            project.ext.gitProps['github.repo.owner'] = owner
            project.ext.gitProps['github.repo.name'] = repo
            project.ext.gitProps['github.repo.url'] = 'https://github.com/' + String.valueOf(owner) + '/' + String.valueOf(repo)

            /*android.defaultConfig.buildConfigField 'String', 'GITHUB_REPO_OWNER', "\"$owner\""
            android.defaultConfig.buildConfigField 'String', 'GITHUB_REPO_NAME', "\"$repo\""
            android.defaultConfig.buildConfigField 'String', 'GITHUB_REPO_URL', "\"https://github.com/$owner/$repo\""*/
        }
    }
}

task appGenerateApiBuildConstants {
    group = groupName
    doLast {
        Properties props = loadProperties('api.properties')
        project.ext['apiProps'] = new HashMap(props)
        /*def ipData = 'api_key_ipdata'
        def ipInfo = 'api_key_ipinfo'
        def ipStack = 'api_key_ipstack'
        if (!props.isEmpty()) {
            android.buildTypes.debug.resValue 'string', ipData, props['keyIpdata']
            android.buildTypes.debug.resValue 'string', ipInfo, props['keyIpinfo']
            android.buildTypes.debug.resValue 'string', ipStack, props['keyIpstack']
        }

        android.defaultConfig.resValue 'string', ipData, ''
        android.defaultConfig.resValue 'string', ipInfo, ''
        android.defaultConfig.resValue 'string', ipStack, ''*/
    }
}

task appCheckIfDirty {
    group = groupName
    dependsOn appGenerateGitProperties
    doLast {
        def dirty = project.ext.gitProps['git.dirty']

        if (dirty.toBoolean()) {
            throw new GradleException('You forget to commit code before building final release build')
        }
    }
}

task appCheckIfSame {
    group = groupName
    dependsOn appGenerateGitProperties
    doLast {
        def branch = project.ext.gitProps['git.branch']

        if (branch == 'slave') {
            def ahead = project.ext.gitProps['git.total.commit.ahead.count']
            def behind = project.ext.gitProps['git.total.commit.behind.count']

            if (ahead != '0') {
                throw new GradleException("You forget to push branch, $ahead commits ahead")
            }

            if (behind != '0') {
                throw new GradleException("You forget to pull branch, $behind commits behind")
            }
        }
    }
}

task appCheckIfTagged {
    group = groupName
    dependsOn appGenerateGitProperties
    doLast {
        def branch = project.ext.gitProps['git.branch']

        if (branch == 'master') {
            def closest = project.ext.gitProps['git.closest.tag.commit.count']

            if (closest != '0') {
                throw new GradleException('You forget to tag last commit before building final release build')
            }
        }
    }
}

task appCopyGoogleIdValuesTask(type: Copy) {
    group = groupName
    from 'src/release/res/values/values.xml'
    into "$project.buildDir/generated/res/google-services/release/values/"
}

task appPrintJavaPackages {
    group = groupName
    doLast {
        Set<File> files = project.android.sourceSets.main.java.srcDirs
        def object = files[0]
        logger.quiet(object.path)
        def packages = fileTree(object)
                .filter { File file -> file.path.endsWith('.java') }
                .collect { it.parentFile.path[object.path.length() + 1..-1].replace '/', '.' }
                .unique()
                .sort()
        packages.each { logger.quiet("list.add(\"$it\");") }
    }
}

task appPrintThirdPartyTasks {
    group = groupName
    doLast {
        //project.tasks.collect { logger.quiet("task=$it dependsOn=$it.dependsOn") }
        project.tasks.stream()
                .filter { !it.class.toString().startsWith('class com.android') }
                .filter { !it.class.toString().startsWith('class org.gradle.api.reporting') }
                .filter { !it.class.toString().startsWith('class org.gradle.api.tasks') }
                .filter { !it.class.toString().startsWith('class org.gradle.configuration') }
                .filter { !it.class.toString().startsWith('class org.gradle.plugins') }
                .filter { !it.class.toString().startsWith('class org.jetbrains') }
                .filter { !it.class.toString().startsWith('class androidx') }
                .filter { !it.actions.empty }
                .filter { it.group != 'Android' }
                .filter { it.group != 'verification' }
                .filter { it.group != 'Firebase Crashlytics' }
                .filter { it.name != 'buildDependents' }
                .filter { !it.name.endsWith("Provider") }
                .collect { logger.quiet("${it.name}.group = groupName") }
    }
}

task appUnzip(type: Copy) {
    group = groupName
    from zipTree("$project.rootDir/sqlite-android-3240000/sqlite-android-3240000.aar")
    into "$project.rootDir/app/src/main/jniLibs/"
    include 'jni/*/*.so'

    eachFile { FileCopyDetails details -> details.relativePath = new RelativePath(true, details.path - 'jni/') }

    includeEmptyDirs = false
}

task appUnzip2(type: Copy) {
    group = groupName
    from zipTree("$project.rootDir/sqlite-android-3240000/sqlite-android-3240000.aar")
    into "$project.rootDir/app/src/main/libs/"
    include 'classes.jar'

    eachFile { FileCopyDetails details -> details.relativePath = new RelativePath(true, 'libsqliteX.jar') }
}

task appGenerateCountryArrays {
    group = groupName
    inputs.file 'src/main/res/raw/emojis.json'
    outputs.file "$project.rootDir/vpn-country-flags/src/main/res/values/arrays.xml"
    doLast {
        def json = new JsonSlurper().parseText(inputs.files.files[0].text)
        def sw = new StringWriter()
        def xml = new MarkupBuilder(sw)

        xml.setDoubleQuotes(true)
        xml.mkp.xmlDeclaration(version: '1.0', encoding: 'utf-8')
        xml.resources() {
            json.each { country ->
                xml.array([name: "$country.flag"]) {
                    country.each { k, v -> item("${v}")
                    }
                }
            }

            /*xml.'string-array'([name: 'country_name']) {
                json.country.each {
                    item(it)
                }
            }

            xml.'string-array'([name: 'country_emoji']) {
                json.emoji.each {
                    item(it)
                }
            }

            xml.'string-array'([name: 'country_flag']) {
                json.flag.each {
                    item(it)
                }
            }

            xml.'integer-array'([name: 'country_id']) {
                json.id.each {
                    item(it)
                }
            }

            xml.'array'([name: 'country_icon']) {
                json.image.each {
                    item(it)
                }
            }*/

        }

        outputs.files.files[0].write(sw.toString())
    }
}

task appGenerateCountriesArray {
    group = groupName
    inputs.file 'src/main/res/raw/emojis.json'
    outputs.file 'src/main/res/values/arrays.xml'
    doLast {
        def json = new JsonSlurper().parseText(inputs.files.files[0].text)
        def sw = new StringWriter()
        def xml = new MarkupBuilder(sw)

        xml.setDoubleQuotes(true)
        xml.mkp.xmlDeclaration(version: '1.0', encoding: 'utf-8')
        xml.resources() {
            xml.array([name: 'countries']) {
                json.flag.each {
                    item("@array/$it")
                }
            }
        }

        outputs.files.files[0].write(sw.toString())
    }
}

/*import com.android.build.gradle.api.BaseVariant

android.applicationVariants.all { BaseVariant variant ->
    if (variant.buildType.name == buildType) {
        variant.preBuildProvider.configure { dependsOn ... }
    }

    variant.preBuildProvider.configure { dependsOn ... }
}*/
